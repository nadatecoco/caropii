# 📊 データ同期設計の検討記録

## 📅 検討日時
2025年7月24日

## 🎯 検討の背景
RAGシステムのプロンプト設計を進める前に、データ同期の仕組みを整理する必要があった。

## 🔄 データ同期の基本方針

### 採用した設計：必要時一括転送
```
1. ユーザーがRAG機能を使用する瞬間
2. iOS → Rails に全データを一括転送
3. Rails側で一時的に保存
4. Gemini APIでRAG処理実行  
5. 処理完了後、数分でデータ自動削除
```

### 検討したが却下した設計：リアルタイム同期
**メリット（ほぼない）:**
- 複数デバイス対応
- 即座にRAG実行

**デメリット（地獄）:**
- 実装が超複雑
- バッテリー消費激増
- サーバーコスト増大
- バグの温床
- セキュリティリスク

## 🗂️ データ更新方式の比較検討

### 🏆 採用：全削除→全保存方式

#### メリット
- **同期ズレが絶対に起きない**
- **エラーハンドリングが簡単**
- **デバッグが楽**（問題あれば全部送り直し）
- **実装がシンプル**

#### 実装方法
```ruby
# iOS側でデータ更新があった場合
1. Rails側の全データを削除
2. iOS側の全データをRails側にコピー
3. 最新データでRAG実行可能
```

### ❌ 却下：1個ずつ同期方式

#### デメリット（バグの温床）
- **同期ズレ地獄**: どちらが正しいデータか分からなくなる
- **競合状態**: 複数の更新が重なった時の処理が複雑
- **部分失敗の処理**: 途中でエラーが起きた時の復旧が困難

## 📊 データ量とパフォーマンスの検討

### ヘビーユーザーの想定データ量
```
食材マスタ: 1000個 × 150バイト = 150KB
食事記録: 3650件 × 100バイト = 365KB  
Apple Watchデータ: 1ヶ月分 = 9KB
合計: 約524KB
```

### 転送時間
```
4G回線: 0.4秒
WiFi: 0.08秒  
5G: 0.04秒
```

### 結論
**現実的には全削除→全保存で十分**
- 重いと感じる転送量は5MB以上
- 食材10,000個相当（現実的にありえない）

## 🔀 データ分割案の検討と却下

### 検討した分割案
```
データを1-10番にランダム分割
→ 更新時は該当番号のデータのみ削除→再保存
→ 転送量を1/10に削減
```

### 却下理由
- **過剰設計**: 現実的なデータ量では不要
- **複雑性増加**: シンプルさを損なう
- **YAGNI原則**: 今は必要ない機能

## 🚀 将来の拡張案（思考メモ）

### 10万個食材の超ヘビーユーザー対応
```
複数データベース分散案:
- 同じ構造のデータベースを2個目、3個目作成
- 食材をランダムに各DBに振り分け
- 更新時は該当DBのみ全削除→全保存
```

**注意**: これは遠い未来の話。今は実装しない。

## 🎯 最終決定事項

1. **データ同期**: 必要時一括転送方式
2. **更新方式**: 全削除→全保存方式  
3. **分割**: 当面は実装せず、将来必要になったら検討
4. **プロンプト設計**: この前提で進める

---

## 📝 次回のタスク
- Gemini API用の具体的なプロンプト設計
- JSONレスポンス形式の詳細定義  
- エラーハンドリング仕様の決定

---

**記録者**: natatekoko + Claude Code  
**ランニング前の最終確認**: 全削除→全保存のシンプル設計で決定 🏃‍♂️